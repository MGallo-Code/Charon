// smtp.go
//
// Mailer interface and SMTPMailer implementation.
// Add other implementations (ses.go, etc.) as separate files in this package.
package mail

import (
	"context"
	"fmt"
	"net/smtp"
	"regexp"
	"strings"
	"time"
)

// Mailer sends transactional emails.
type Mailer interface {
	// SendPasswordReset sends a password reset email containing the raw token.
	// vars is a map of %%key%% placeholder names to replacement values (e.g. "firstName": "John").
	// The mailer substitutes all %%key%% occurrences in subject and body before sending.
	// Unresolved placeholders are stripped rather than left in the email.
	SendPasswordReset(ctx context.Context, toEmail, token string, expiresIn time.Duration, vars map[string]string) error

	// SendEmailVerification sends an email verification link containing the raw token.
	// vars is a map of %%key%% placeholder names to replacement values.
	// Unresolved placeholders are stripped rather than left in the email.
	SendEmailVerification(ctx context.Context, toEmail, token string, expiresIn time.Duration, vars map[string]string) error
}

// SMTPConfig holds all configuration for SMTPMailer.
type SMTPConfig struct {
	Host          string
	Port          string
	Username      string
	Password      string
	FromAddress   string
	ResetURLBase  string
	VerifyURLBase string
}

// SMTPMailer sends transactional email via SMTP.
// Compatible with any SMTP provider: SES, Mailgun, Mailpit (local dev), etc.
type SMTPMailer struct {
	cfg SMTPConfig
}

// NewSMTPMailer creates an SMTPMailer with the given config.
func NewSMTPMailer(cfg SMTPConfig) *SMTPMailer {
	return &SMTPMailer{cfg: cfg}
}

// NopMailer discards all outbound email. Used when SMTP is not configured.
type NopMailer struct{}

func (n *NopMailer) SendPasswordReset(_ context.Context, _, _ string, _ time.Duration, _ map[string]string) error {
	return nil
}

func (n *NopMailer) SendEmailVerification(_ context.Context, _, _ string, _ time.Duration, _ map[string]string) error {
	return nil
}

// unresolvedPlaceholder matches any %%word%% placeholder left after substitution.
var unresolvedPlaceholder = regexp.MustCompile(`%%\w+%%`)

// applyVars substitutes %%key%% placeholders in tmpl using vars, then strips any
// that remain unresolved rather than leaving them in the output.
func applyVars(tmpl string, vars map[string]string) string {
	pairs := make([]string, 0, len(vars)*2)
	for key, value := range vars {
		pairs = append(pairs, "%%"+key+"%%", value)
	}
	substituted := strings.NewReplacer(pairs...).Replace(tmpl)
	return unresolvedPlaceholder.ReplaceAllString(substituted, "")
}

// formatDuration renders a duration as a human-readable expiry string.
// e.g. time.Hour → "1 hour", 48*time.Hour → "2 days", 30*time.Minute → "30 minutes".
func formatDuration(d time.Duration) string {
	switch {
	case d >= 24*time.Hour:
		days := int(d.Hours() / 24)
		if days == 1 {
			return "1 day"
		}
		return fmt.Sprintf("%d days", days)
	case d >= time.Hour:
		hours := int(d.Hours())
		if hours == 1 {
			return "1 hour"
		}
		return fmt.Sprintf("%d hours", hours)
	default:
		mins := int(d.Minutes())
		if mins == 1 {
			return "1 minute"
		}
		return fmt.Sprintf("%d minutes", mins)
	}
}

// SendPasswordReset emails a password reset link to toEmail.
// token is the raw (unhashed) token generated by the handler.
func (m *SMTPMailer) SendPasswordReset(_ context.Context, toEmail, token string, expiresIn time.Duration, vars map[string]string) error {
	// Merge caller vars into a fresh map, then inject mailer-owned keys.
	// Mailer keys are added last so they can't be overridden by the caller.
	merged := make(map[string]string, len(vars)+3)
	for k, v := range vars {
		merged[k] = v
	}
	merged["toEmail"] = toEmail
	merged["expiresIn"] = formatDuration(expiresIn)
	merged["url"] = m.cfg.ResetURLBase + "?token=" + token

	body := "You requested a password reset.\n\n" +
		"Click the link below to choose a new password:\n\n" +
		"%%url%%\n\n" +
		"This link expires in %%expiresIn%%. If you did not request a reset, ignore this email."

	msg := "From: " + m.cfg.FromAddress + "\r\n" +
		"To: " + toEmail + "\r\n" +
		"Subject: Reset your password\r\n" +
		"MIME-Version: 1.0\r\n" +
		"Content-Type: text/plain; charset=UTF-8\r\n" +
		"\r\n" +
		body

	// Fourth arg to PlainAuth is host only (no port) -- used for SASL negotiation.
	auth := smtp.PlainAuth("", m.cfg.Username, m.cfg.Password, m.cfg.Host)
	if err := smtp.SendMail(m.cfg.Host+":"+m.cfg.Port, auth, m.cfg.FromAddress, []string{toEmail}, []byte(applyVars(msg, merged))); err != nil {
		return fmt.Errorf("sending password reset email: %w", err)
	}
	return nil
}

// SendEmailVerification emails a verification link to toEmail.
// token is the raw (unhashed) token generated by the handler.
func (m *SMTPMailer) SendEmailVerification(_ context.Context, toEmail, token string, expiresIn time.Duration, vars map[string]string) error {
	// Merge caller vars into a fresh map, then inject mailer-owned keys.
	// Mailer keys are added last so they can't be overridden by the caller.
	merged := make(map[string]string, len(vars)+3)
	for k, v := range vars {
		merged[k] = v
	}
	merged["toEmail"] = toEmail
	merged["expiresIn"] = formatDuration(expiresIn)
	merged["url"] = m.cfg.VerifyURLBase + "?token=" + token

	body := "Please verify your email address to complete registration.\n\n" +
		"Click the link below to confirm your email:\n\n" +
		"%%url%%\n\n" +
		"This link expires in %%expiresIn%%. If you did not create an account, ignore this email."

	msg := "From: " + m.cfg.FromAddress + "\r\n" +
		"To: " + toEmail + "\r\n" +
		"Subject: Confirm your email address\r\n" +
		"MIME-Version: 1.0\r\n" +
		"Content-Type: text/plain; charset=UTF-8\r\n" +
		"\r\n" +
		body

	// Fourth arg to PlainAuth is host only (no port) -- used for SASL negotiation.
	auth := smtp.PlainAuth("", m.cfg.Username, m.cfg.Password, m.cfg.Host)
	if err := smtp.SendMail(m.cfg.Host+":"+m.cfg.Port, auth, m.cfg.FromAddress, []string{toEmail}, []byte(applyVars(msg, merged))); err != nil {
		return fmt.Errorf("sending email verification: %w", err)
	}
	return nil
}
