// smtp.go
//
// Mailer interface and SMTPMailer implementation.
// Add other implementations (ses.go, etc.) as separate files in this package.
package mail

import (
	"context"
	"fmt"
	"net/smtp"
)

// Mailer sends transactional emails.
type Mailer interface {
	// SendPasswordReset sends a password reset email containing the raw token.
	SendPasswordReset(ctx context.Context, toEmail, token string, firstName, lastName *string) error

	// SendEmailVerification sends an email verification link containing the raw token.
	SendEmailVerification(ctx context.Context, toEmail, token string, firstName, lastName *string) error
}

// SMTPMailer sends transactional email via SMTP.
// Compatible with any SMTP provider: SES, Mailgun, Mailpit (local dev), etc.
type SMTPMailer struct {
	host          string
	port          string
	username      string
	password      string
	fromAddress   string
	resetURLBase  string
	verifyURLBase string
}

// NewSMTPMailer creates an SMTPMailer with the given credentials.
func NewSMTPMailer(host, port, username, password, fromAddress, resetURLBase, verifyURLBase string) *SMTPMailer {
	return &SMTPMailer{
		host:          host,
		port:          port,
		username:      username,
		password:      password,
		fromAddress:   fromAddress,
		resetURLBase:  resetURLBase,
		verifyURLBase: verifyURLBase,
	}
}

// NopMailer discards all outbound email. Used when SMTP is not configured.
type NopMailer struct{}

func (n *NopMailer) SendPasswordReset(_ context.Context, _, _ string, _, _ *string) error {
	return nil
}

func (n *NopMailer) SendEmailVerification(_ context.Context, _, _ string, _, _ *string) error {
	return nil
}

// greeting returns "Hi <firstName>,\n\n" if firstName is set, empty string otherwise.
func greeting(firstName *string) string {
	if firstName != nil && *firstName != "" {
		return "Hi " + *firstName + ",\n\n"
	}
	return ""
}

// SendPasswordReset emails a password reset link to toEmail.
// token is the raw (unhashed) token generated by the handler.
func (m *SMTPMailer) SendPasswordReset(_ context.Context, toEmail, token string, firstName, lastName *string) error {
	resetURL := m.resetURLBase + "?token=" + token

	body := greeting(firstName) +
		"You requested a password reset.\n\n" +
		"Click the link below to choose a new password:\n\n" +
		resetURL + "\n\n" +
		"This link expires in 1 hour. If you did not request a reset, ignore this email."

	msg := "From: " + m.fromAddress + "\r\n" +
		"To: " + toEmail + "\r\n" +
		"Subject: Reset your password\r\n" +
		"MIME-Version: 1.0\r\n" +
		"Content-Type: text/plain; charset=UTF-8\r\n" +
		"\r\n" +
		body

	// Fourth arg to PlainAuth is host only (no port) -- used for SASL negotiation.
	auth := smtp.PlainAuth("", m.username, m.password, m.host)
	if err := smtp.SendMail(m.host+":"+m.port, auth, m.fromAddress, []string{toEmail}, []byte(msg)); err != nil {
		return fmt.Errorf("sending password reset email: %w", err)
	}
	return nil
}

// SendEmailVerification emails a verification link to toEmail.
// token is the raw (unhashed) token generated by the handler.
func (m *SMTPMailer) SendEmailVerification(_ context.Context, toEmail, token string, firstName, lastName *string) error {
	verifyURL := m.verifyURLBase + "?token=" + token

	body := greeting(firstName) +
		"Please verify your email address to complete registration.\n\n" +
		"Click the link below to confirm your email:\n\n" +
		verifyURL + "\n\n" +
		"This link expires in 24 hours. If you did not create an account, ignore this email."

	msg := "From: " + m.fromAddress + "\r\n" +
		"To: " + toEmail + "\r\n" +
		"Subject: Confirm your email address\r\n" +
		"MIME-Version: 1.0\r\n" +
		"Content-Type: text/plain; charset=UTF-8\r\n" +
		"\r\n" +
		body

	// Fourth arg to PlainAuth is host only (no port) -- used for SASL negotiation.
	auth := smtp.PlainAuth("", m.username, m.password, m.host)
	if err := smtp.SendMail(m.host+":"+m.port, auth, m.fromAddress, []string{toEmail}, []byte(msg)); err != nil {
		return fmt.Errorf("sending email verification: %w", err)
	}
	return nil
}
